%!TEX Root=./paper.tex



\begin{algorithm}
  \caption{Auxiliary procedure: \textsc{handleCall}
  \label{fig:aux-func-recS}}
\begin{algorithmic}[1]

\Function{handleCall}{$\workstate, \inst$}
\State $f \gets  \Call{targetFunction}{\workstate, \inst}$ \label{alg:call-find-target}
\If{$f \in \skipFunctions$}
  \State $\snapshot \gets \Call{createSnapshot}{\workstate}$ \label{alg:take-snapshot}
  \State $\workstate.\skipped \gets \workstate.\skipped + (f,\snapshot)$ \label{alg:record-snapshot}
\Else
  \State $\Call{executeCall}{\workstate}$ \label{alg:call-normal}
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Auxiliary procedure: \textsc{handleLoad}
  \label{fig:aux-func-recS}}
\begin{algorithmic}[1]

\Function{handleLoad}{$\workstate, \inst$}
\State $\addr \gets \Call{getLoadAddress}{\workstate, \inst}$
\If{$\Call{mayMod}{\workstate,\workstate.\skipped,\addr}$}%.\skipped}$}
  %\TODO: Explain that this is a simplification and recovery states are maintained in a pool
  \State $\Call{createRecoveryState}{\workstate,\addr}$ \label{alg:call-recover}
\Else
  \State \Call{executeLoad}{$\workstate, \inst$}  \label{alg:load-normal}
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Auxiliary procedure: \textsc{mayMod}.
  \label{fig:aux-func-may-mod}}
\begin{algorithmic}[1]


\Function{mayMod}{$\workstate, \funclist, \addr$}
  \ForEach{$(f,\snapshot) \in \funclist$}
    \If{$\Call{allocSite}{\workstate,\addr} \in \Call{modSet}{f}$} \label{alg:maymod-static}
      \If{$\addr \not \in \workstate.\owset$} \label{alg:maymod-dynamic}
         \State \Return{$\mathit{true}$}
       \EndIf
    \EndIf
  \EndFor
  \State \Return{$\mathit{false}$}
\EndFunction

\end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Auxiliary procedure: \textsc{handleBranch}
  \label{fig:aux-func-recS}}
\begin{algorithmic}[1]

\Function{handleBranch}{$\workstate, \inst$}
\If{$\workstate.\isRecovery$} \label{alg:branch-check-recovery}
  \State $\varphi = \Call{getCondition}{\workstate, \inst}$  \label{alg:branch-get-cond}
  \State $\dependentState \gets  \Call{getDependentState}{\workstate}$ \label{alg:get-dependent}
  \If{$\Call{feasible}{\workstate, \varphi}$} \label{alg:branch-feasible-true}
    \State $\Call{addPathCondition}{\workstate, \varphi}$ \label{alg:add-pc-true-recS}
    \State $\Call{addPathCondition}{\dependentState, \varphi}$ \label{alg:add-pc-true-depS}
  \EndIf
  \If{$\Call{feasible}{\workstate, \neg \varphi}$} \label{alg:branch-feasible-false}
    \State $\workstate' \gets \Call{fork}{\workstate}$ \label{alg:branch-fork-false1}
    \State $\dependentState' \gets \Call{fork}{\dependentState}$ \label{alg:branch-fork-false2}
    \State $\Call{addPathCondition}{\workstate', \neg \varphi}$ \label{alg:add-pc-false-recS}
    \State $\Call{addPathCondition}{\dependentState', \neg \varphi}$ \label{alg:add-pc-false-depS}
    \State $\worklist \gets \worklist \cup \{\workstate', \dependentState'\}$ \label{alg:push-both}
  \EndIf
\Else
  \State \Call{executeBranch}{$\workstate$}  \label{alg:branch-normal}
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Auxiliary procedure: \textsc{handleStore}
  \label{fig:aux-func-recS}}
\begin{algorithmic}[1]

\Function{handleStore}{$\workstate, \inst$}
\State $\addr \gets \Call{getStoreAddress}{\workstate, \inst}$
\State $\Call{executeStore}{\workstate,\addr}$ \label{alg:store-normal}
\If{$\workstate.\isRecovery$} \label{alg:store-check-recovery}
  \State $\dependentState \gets \Call{getDependentState}{\workstate}$
  \State \Call{executeStore}{$\dependentState, \addr$} \label{alg:store-udpate-dep-states}
\Else
  \State $\workstate.\owset \gets \workstate.\owset \cup \{\addr\}$ \label{alg:record-overwrite}
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Auxiliary procedure: \textsc{handleExit}
  \label{fig:aux-func-recS}}
\begin{algorithmic}[1]

\Function{handleExit}{$\workstate, \inst$}
\If{$\workstate.\isRecovery \land \Call{retInSkip}{\workstate}$} \label{alg:exit-check-recovery}
  \State \Call{terminate}{$\recoveryState$} \label{alg:exit-terminate-recovery}
  \State $\dependentState \gets  \Call{getDependentState}{\workstate}$ \label{alg:exit-extract-dependent}
  \State \Call{resume}{$\dependentState$} \label{alg:exit-resume}
  \State $\worklist \gets  \worklist \cup \{\dependentState\}$
\Else
  \State \Call{executeExit}{$\workstate$}  \label{alg:exit-normal}
  \label{alg:push-worklist-exit}
\EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
  \caption{Auxiliary procedure: \textsc{createRecoveryState}
  \label{fig:aux-func-recS}}
\begin{algorithmic}[1]

\Function{createRecoveryState}{$\workstate, \addr$}
  \ForEach{$(f,\snapshot) \in \workstate.\skipped$} \label{alg:recover-foreach}
    \If{$\Call{mayMod}{\workstate, (f,\snapshot) ,\addr}$} \label{alg:recover-if-found}
       \State $\dependentState \gets \workstate$ \label{alg:recover-gen-depS}
       \State $\Call{suspend}{\dependentState}$ \label{alg:recover-suspend}
       \State $\gc \gets  \Call{getGuidingConstraints}{\dependentState}$ \label{alg:recover-get-gc}
       \State $\recoveryState \gets \Call{fork}{\snapshot}$ \label{alg:recover-gen-recS}
       \State $\recoveryState \gets \Call{addPathConditions}{\recoveryState,\gc}$ \label{alg:add-guiding-constraints}
       \State $\recoveryState.\isRecovery \gets \mtrue$ \label{alg:recover-set-is-recS}
       % TODO: fix the slice call...
       \State $\Call{slice}{\recoveryState,\addr}$ \label{alg:recover-slice}
       \State $\recoveryState.dependentState = \dependentState$ \label{alg:set-dependent-state}
       \State $\recoveryState.loadAddr = \addr$ \label{alg:set-load-addr}
       \State $\worklist \gets \worklist \cup \{\recoveryState\}$
       \label{alg:push-worklist-recovery}
    \EndIf
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "paper"
%%% End:
